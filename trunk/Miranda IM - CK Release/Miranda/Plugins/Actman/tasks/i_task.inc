{}
const
  HWND_MESSAGE = HWND(-3);
const
  ACF_ASSIGNED = $80000000;  // Task assigned
  ACF_DISABLED = $10000000;  // Task disabled

  TCF_ABSOLUTE     = $00000001;
  TCF_IMMEDIATELY  = $00000002;
  TCF_NONZEROBREAK = $00000004;

const
  WM_RESETTASKS = WM_USER+1312;
  WM_FIRSTTASK  = WM_USER+1313;
  WM_LASTTASK   = WM_FIRSTTASK+1000;

type
  pTaskRec = ^tTaskRec;
  tTaskRec = record
    flags     :dword;
    name      :PWideChar; // name for task
    action    :dword;     // assigned action
    // maybe tSystemTime is better? but harder to save
    dayoffset :integer;   //!! offset, days
    starttime,            // task starttime
    interval  :TFileTime; // interval for repeat
    count     :integer;   // repeat count

    timer     :uint_ptr;  // (runtime) timer handle
    curcount  :integer;   // (runtime) repeat count
  end;
  pTaskList = ^tTaskList;
  tTaskList  = array [0..1023] of tTaskRec;

var
  TaskList:pTaskList = nil;
  MaxTasks:integer = 0;
  settings:HWND = 0;

procedure TimerProc(wnd:HWND;uMsg:uint;idEvent:uint_ptr;dwTime:dword); stdcall;
var
  i:integer;
  res:int_ptr;
begin
  for i:=0 to MaxTasks-1 do
  begin
    if (TaskList[i].flags and (ACF_ASSIGNED or ACF_DISABLED))=ACF_ASSIGNED then
      if TaskList[i].timer=idEvent then
      begin
        res:=CallService(MS_ACT_RUNBYID,TaskList[i].action,0);
        dec(TaskList[i].curcount);
        if (TaskList[i].curcount<=0) or 
           ((res<>0) and ((TaskList[i].flags and TCF_NONZEROBREAK)<>0)) then
        begin
          KillTimer(0,idEvent);
          TaskList[i].timer:=0;
          TaskList[i].flags:=TaskList[i].flags or ACF_DISABLED;
        end;
        break;
      end;
  end;
end;

procedure SetTask(var task:tTaskRec);
var
  ltime:uint;
  uli1,uli2:ULARGE_INTEGER;
  sft:tFileTime;
  st:tSystemTime;
  dif:int64;
begin
  // Check task time
  if (task.flags and TCF_ABSOLUTE)<>0 then
  begin
    uli1.LowPart :=task.starttime.dwLowDateTime;
    uli1.HighPart:=task.starttime.dwHighDateTime;
    GetLocalTime(st);
    SystemTimeToFileTime(st,sft);
    uli2.LowPart :=sft.dwLowDateTime;
    uli2.HighPart:=sft.dwHighDateTime;
    dif:=uli1.QuadPart-uli2.QuadPart;
    if dif>0 then // time in future
      ltime:=dif div 10000 // 100ns to 1 ms
    else // was in past
    begin
      task.flags:=task.flags or ACF_DISABLED;
      exit;
    end;
  end
  else
  begin
    // days+hours+minutes+seconds+millseconds
    FileTimeToSystemTime(task.starttime,st);
    ltime:={st.wMilliseconds+}st.wSecond*1000+st.wMinute*1000*60+
           st.wHour*60*60*1000+task.dayoffset*24*60*60*1000;
  end;
  // set timer
  task.curcount:=task.count;
  task.timer   :=SetTimer(0,0,ltime,@TimerProc);
end;

procedure SetAllTasks;
var
  i:integer;
begin
  for i:=0 to MaxTasks-1 do
  begin
    if (TaskList[i].flags and (ACF_ASSIGNED or ACF_DISABLED))=ACF_ASSIGNED then
      SetTask(TaskList[i]);
  end;
end;

procedure StopAllTasks;
var
  i:integer;
begin
  for i:=0 to MaxTasks-1 do
  begin
    if (TaskList[i].flags and (ACF_ASSIGNED or ACF_DISABLED))=ACF_ASSIGNED then
      if TaskList[i].timer<>0 then
      begin
        KillTimer(0,TaskList[i].timer);
        TaskList[i].timer:=0;
      end;
  end;
end;

procedure ClearTasks;
var
  i:integer;
begin
  for i:=0 to MaxTasks-1 do
  begin
    with TaskList[i] do
    begin
//!!      if (flags and ACF_ASSIGNED)<>0 then
        mFreeMem(name);
    end;
  end;
  FreeMem(TaskList);
  MaxTasks:=0;
end;

function CreateNewTask:integer;
var
  i:integer;
  tmp:pTaskList;
  st:tSystemTime;
begin
  result:=-1;
  // if list is not empty, search for hole
  if MaxTasks>0 then
  begin
    for i:=0 to MaxTasks-1 do
    begin
      if (TaskList[i].flags and ACF_ASSIGNED)=0 then
      begin
        FillChar(TaskList[i],SizeOf(tTaskRec),0);
        result:=i;
        break;
      end;
    end;
  end;
  if result<0 then
  begin
    // not found or empty list
    i:=(MaxTasks+16)*SizeOf(tTaskRec);
    GetMem  (tmp ,i);
    FillChar(tmp^,i,0);
    if MaxTasks>0 then
    begin
      move(TaskList^,tmp^,MaxTasks*SizeOf(tTaskRec));
      FreeMem(TaskList);
    end;
    TaskList:=tmp;
    result:=MaxTasks;
    inc(MaxTasks,16);
  end;
  with TaskList^[result] do
  begin
    flags:=flags or ACF_ASSIGNED or ACF_DISABLED or TCF_ABSOLUTE;
    //!!! CHEAT
    GetSystemTime(st);
    st.wHour  :=0;
    st.wMinute:=0;
    st.wSecond:=1;
    SystemTimeToFileTime(st,interval);
  end;
end;
